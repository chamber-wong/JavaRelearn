package demo;
/*
 * 总结成员变量的特点:
 * 1.在创建对象的时候被赋予默认值
 * 2.可以在类中定义变量的时候直接赋值.
 * 3.可以在没有被static修饰的方法以外直接使用
 * 
 * 比较成员变量和局部变量?
 * 1.作用域:成员变量是整个对象.局部变量是从定义开始到所在的函数/if/for结束
 * 2.默认值:成员变量会有默认值,局部变量没有默认值,要想使用必须先赋值
 * 3.释放机制:成员变量跟对象保持一致,通过垃圾回收机制回收,局部变量使用完立即释放
 * 4.存放的位置:成员变量放在堆区中的对象中,局部变量放在栈区中的方法中.
 * 
 * 将成员分成两类:静态的(被static修饰)和非静态的
 * 静态的:静态的方法和变量----可以既可以通过引用又可以通过类名调用,推荐类名调用
 * 非静态的:非静态的方法和变量---只能使用引用调用
 * 
 * 为什么可以通过类名直接调用静态的成员变量?
 * *当成员被static修饰之后就变成了静态的,会在class生成的同时放在静态方法区中一份,而静态方法区的特点是内容会随着
程序的结束而释放,所以对象的创建与否不能影响他们的调用,所以可以直接使用类名调用


静态的成员方法和非静态的成员方法优先使用哪一个?
答:优先使用静态的成员方法
原因:静态的方法比非静态的效率高,节省内存.

注意:但是有一种情况例外:当方法中必须使用非静态的成员变量的时候,这时必须使用非静态的方法

总结:被static修饰的成员变量会变成静态的成员变量,成员方法会变成静态的成员方法.
 */
public class Demo2 {
	public static void main(String[] args) {
		Person person = new Person();
		person.name = "冰冰";
		person.age = 18;//引用可以直接调用非静态的成员
		person.height = 170;//引用可以调用静态的成员,但是系统不推荐
		
		person.show();
		person.eat();
		
		Person.height = 30;//通过类名直接调用静态的成员
		Person.eat();
		//Person.age = 4; 类名不能调用非静态的成员
	}
}

class Person{
	String name;
	int age;
	static int height;//静态的成员变量
	
	public void show(){
		System.out.println("show");
	}
	
	public static void eat(){//静态的成员方法
		System.out.println("eat");
	}
}
